<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="常用配置 #  开发模式和生产模式 #   从ES 5开始，支持 Development和Production 两种运行模式。
 Bootstrap Checks #   一个集群在Production Mode时，启动时必须通过所有Bootstrap 检测，否则会启动失败。Bootstrap Checks 可以分为两类 JVM &amp; Linux Checks。Linux Checks只针对Linux系统。
 JVM设定 #   从ES 6开始，只支持 64 位的JVM，JVM的设置可以在config/jvm.options中设置。尽量避免修改默认配置：
 将内存 Xms 和 Xmx 设置成一样，避免heap resize 时引发停顿 Xmx设置不要超过物理内存的 50%（lucene索引会用内存）；单个节点，最大内存建议不超过32G（JVM内存小于32G时会使用指针压缩技术） 生产环境，JVM必须使用Server模式 关闭JVM Swapping   集群配置设定 #    静态设定
 静态配置文件尽量简洁：按照文档设置所有相关系统参数。elasticsearch.yml 配置文件中尽量只写必备参数。
   动态设定
 其他的设置项可以通过 API 动态进行设定。动态设定分 transient 和 persistent 两种，都会覆盖 elasticsearch.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="集群运维" />
<meta property="og:description" content="常用配置 #  开发模式和生产模式 #   从ES 5开始，支持 Development和Production 两种运行模式。
 Bootstrap Checks #   一个集群在Production Mode时，启动时必须通过所有Bootstrap 检测，否则会启动失败。Bootstrap Checks 可以分为两类 JVM &amp; Linux Checks。Linux Checks只针对Linux系统。
 JVM设定 #   从ES 6开始，只支持 64 位的JVM，JVM的设置可以在config/jvm.options中设置。尽量避免修改默认配置：
 将内存 Xms 和 Xmx 设置成一样，避免heap resize 时引发停顿 Xmx设置不要超过物理内存的 50%（lucene索引会用内存）；单个节点，最大内存建议不超过32G（JVM内存小于32G时会使用指针压缩技术） 生产环境，JVM必须使用Server模式 关闭JVM Swapping   集群配置设定 #    静态设定
 静态配置文件尽量简洁：按照文档设置所有相关系统参数。elasticsearch.yml 配置文件中尽量只写必备参数。
   动态设定
 其他的设置项可以通过 API 动态进行设定。动态设定分 transient 和 persistent 两种，都会覆盖 elasticsearch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wxyyrain.github.io/docs/elasticsearch/mds/7_cluster_setting/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-01-14T22:15:37+08:00" />
<meta property="article:modified_time" content="2021-01-14T22:15:37+08:00" />

<title>集群运维 | My New Hugo Site</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css" integrity="sha256-RhgbyTN1upMgJudTs3xA5v&#43;LsWqe93DHi8xmPkV3sbo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.0b91e583ed41c2dac49fa05a42853ad2e5ea48e24d6531669ba739d0df5c8a10.js" integrity="sha256-C5Hlg&#43;1BwtrEn6BaQoU60uXqSOJNZTFmm6c50N9cihA=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>数据结构和算法</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/algorithm/mds/base_data_structure/" class="">一维</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/algorithm/mds/data_structure_2/" class="">二维</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/algorithm/mds/data_structure_3/" class="">特殊</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/algorithm/mds/algorithm/" class="">算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/" class="">分布式数据系统</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/mds/data_copy/" class="">数据复制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/mds/data_shard/" class="">数据分区</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/mds/challenge/" class="">分布式系统的挑战</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/mds/transaction/" class="">事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/distribute/mds/consistency/" class="">一致性与共识</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/" class="">Elasticsearch</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/0_pre/" class="">前置知识</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/1_basic/" class="">基本使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/2_distribute/" class="">分布式原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/3_search/" class="">搜索</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/4_aggs/" class="">聚合</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/5_model_design/" class="">数据建模</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/6_scale_out/" class="">水平扩展集群</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/7_cluster_setting/" class=" active">集群运维</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/elasticsearch/mds/8_index_lifecycle/" class="">索引生命周期管理</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/" class="">MySQL</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/architecture/" class="">基础架构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/log/" class="">日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/transaction/" class="">事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/1_index/" class="">索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/lock/" class="">锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/questions/" class="">Questions</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://wxyyrain.github.io/docs/mysql/mds/file/" class="">表数据</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>K8s</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Redis</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>微服务</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>集群运维</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#常用配置">常用配置</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#监控集群">监控集群</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#潜在问题">潜在问题</a></li>
    <li><a href="#集群-yellow-与-red-问题">集群 Yellow 与 Red 问题</a></li>
    <li><a href="#提升写性能">提升写性能</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#提升读性能">提升读性能</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#段合并优化及注意事项">段合并优化及注意事项</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#缓存及使用breaker限制内存使用">缓存及使用Breaker限制内存使用</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="常用配置">
  常用配置
  <a class="anchor" href="#%e5%b8%b8%e7%94%a8%e9%85%8d%e7%bd%ae">#</a>
</h2>
<h4 id="开发模式和生产模式">
  开发模式和生产模式
  <a class="anchor" href="#%e5%bc%80%e5%8f%91%e6%a8%a1%e5%bc%8f%e5%92%8c%e7%94%9f%e4%ba%a7%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<blockquote>
<p>从ES 5开始，支持 Development和Production 两种运行模式。</p>
</blockquote>
<p><img src="/images/es_pic/run_mode.png" alt="" /></p>
<h4 id="bootstrap-checks">
  Bootstrap Checks
  <a class="anchor" href="#bootstrap-checks">#</a>
</h4>
<blockquote>
<p>一个集群在Production Mode时，启动时必须通过所有Bootstrap 检测，否则会启动失败。Bootstrap Checks 可以分为两类 JVM &amp; Linux Checks。Linux Checks只针对Linux系统。</p>
</blockquote>
<p><img src="/images/es_pic/boot_checks.png" alt="" /></p>
<h4 id="jvm设定">
  JVM设定
  <a class="anchor" href="#jvm%e8%ae%be%e5%ae%9a">#</a>
</h4>
<blockquote>
<p>从ES 6开始，只支持 64 位的JVM，JVM的设置可以在config/jvm.options中设置。尽量避免修改默认配置：</p>
<ul>
<li>将内存 Xms 和 Xmx 设置成一样，避免heap resize 时引发停顿</li>
<li>Xmx设置不要超过物理内存的 50%（lucene索引会用内存）；单个节点，最大内存建议不超过32G（JVM内存小于32G时会使用指针压缩技术）</li>
<li>生产环境，JVM必须使用Server模式</li>
<li>关闭JVM Swapping</li>
</ul>
</blockquote>
<h4 id="集群配置设定">
  集群配置设定
  <a class="anchor" href="#%e9%9b%86%e7%be%a4%e9%85%8d%e7%bd%ae%e8%ae%be%e5%ae%9a">#</a>
</h4>
<ul>
<li>
<p>静态设定</p>
<blockquote>
<p>静态配置文件尽量简洁：按照文档设置所有相关系统参数。elasticsearch.yml 配置文件中尽量只写必备参数。</p>
</blockquote>
</li>
<li>
<p>动态设定</p>
<blockquote>
<p>其他的设置项可以通过 API 动态进行设定。动态设定分 transient 和 persistent 两种，都会覆盖 elasticsearch.yml 中的设置。transient 在集群重启后会丢失；persistent 在集群重启后不会丢失。</p>
</blockquote>
<table>
<thead>
<tr>
<th>优先级</th>
<th>设置</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Transient Settings</td>
</tr>
<tr>
<td>2</td>
<td>Persistent Settings</td>
</tr>
<tr>
<td>3</td>
<td>Command-line Settings</td>
</tr>
<tr>
<td>4</td>
<td>Config file Settings</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="系统设置">
  系统设置
  <a class="anchor" href="#%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae">#</a>
</h4>
<blockquote>
<p>参照文档 Setup ELasticsearch &gt; Important System Configuration。</p>
</blockquote>
<h4 id="最佳实践">
  最佳实践
  <a class="anchor" href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5">#</a>
</h4>
<ul>
<li>
<p>网络</p>
<ul>
<li>单个集群不要跨数据中心进行部署（不要使用WAN）</li>
<li>节点之间的hops 越少越好</li>
<li>如果有多块网卡，最好将transport 和http 绑定到不同的网卡，并设置不同的防火墙 Rules</li>
<li>按需为 Coordinating Node 或 Ingest Node 配置负载均衡</li>
</ul>
</li>
<li>
<p>内存设定计算实例</p>
<ul>
<li>
<p>内存大小要根据Node 需要存储的数据来进行估算：搜索类的比例建议 1:16；日志类：1:48 - 1:96 之间。</p>
<blockquote>
<p>假设总数据量1T，设置一个副本 = 2T 总数据量。</p>
<ol>
<li>搜索类项目，每个节点 31（JVM内存） * 16 = 496 G，加上预留空间。所以每个节点最多400G 数据，至少需要5 个数据节点；</li>
<li>日志类项目，每个节点 31 * 50 = 1550 GB， 两个数据节点即可。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>
<p>存储</p>
<ul>
<li>推荐使用SSD，使用本地存储（Local Disk），避免使用 SAN NFS/ AWS / Azure filesystem</li>
<li>可以在本地指定多个 &ldquo;path.data&rdquo;，以支持使用多块磁盘</li>
<li>ES 本来提供了很好的HA 机制，无需使用RAID 1/5/10</li>
<li>可以在Warm 节点上使用Spinning Disk，但是需要关闭Concurrent Merges</li>
<li>Trim 你的SSD</li>
</ul>
</li>
<li>
<p>服务器硬件</p>
<ul>
<li>建议使用中等配置的机器，不建议使用过于强劲的硬件配置（建议使用中等配置的机器，不建议使用过于强劲的硬件配置）</li>
<li>不建议在一台服务器上运行多个节点</li>
</ul>
</li>
<li>
<p>Throttles限流</p>
<blockquote>
<p>为 Relocation 和Recovery 设置限流，避免过多任务对集群产生性能影响。</p>
</blockquote>
<ul>
<li>
<p>Recovery</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">Cluster.routing.allocation.node_concurrent_recoveries：</span><span style="color:#ae81ff">2</span>
</code></pre></div></li>
<li>
<p>Relocation</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">Cluster.routing.allocation.cluster_concurrent_rebalance：</span><span style="color:#ae81ff">2</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="集群设置">
  集群设置
  <a class="anchor" href="#%e9%9b%86%e7%be%a4%e8%ae%be%e7%bd%ae">#</a>
</h4>
<ul>
<li>
<p>关闭 Dynamic Indexes</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">PUT</span> <span style="color:#960050;background-color:#1e0010">_cluster/settings</span>
{
  <span style="color:#f92672">&#34;persistend&#34;</span> : {
    <span style="color:#f92672">&#34;actino.auto_create_index&#34;</span> : <span style="color:#66d9ef">false</span>
  }
}
<span style="color:#75715e">// 也可以设置白名单
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">PUT</span> <span style="color:#960050;background-color:#1e0010">_cluster/settings</span>
{
  <span style="color:#f92672">&#34;persistend&#34;</span> : {
    <span style="color:#f92672">&#34;actino.auto_create_index&#34;</span> : <span style="color:#e6db74">&#34;logstash-*, .kibana*&#34;</span>
  }
}
</code></pre></div></li>
<li>
<p>安全设定</p>
<ul>
<li>打开Authentication &amp; Authorization</li>
<li>实现索引和字段级的安全控制</li>
<li>节点间通信加密</li>
<li>Enable HTTPS</li>
<li>Audit logs</li>
</ul>
</li>
</ul>
<h2 id="监控集群">
  监控集群
  <a class="anchor" href="#%e7%9b%91%e6%8e%a7%e9%9b%86%e7%be%a4">#</a>
</h2>
<h4 id="stats相关api">
  Stats相关API
  <a class="anchor" href="#stats%e7%9b%b8%e5%85%b3api">#</a>
</h4>
<ul>
<li>
<p>Node Stats</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// 节点级别统计信息
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/stats</span>
</code></pre></div></li>
<li>
<p>CLuster Stats</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// 集群级别统计信息，文档总数、索引总数等
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cluster/stats</span>
</code></pre></div></li>
<li>
<p>Index Stats</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// 索引级别统计信息
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">索引名/_stats</span>
</code></pre></div></li>
</ul>
<h4 id="task-api">
  Task API
  <a class="anchor" href="#task-api">#</a>
</h4>
<ul>
<li>
<p>Task</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// 查看所有的 tasks
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_tasks</span>
<span style="color:#75715e">// Pending Cluster Tasks
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cluster/pending_tasks</span>
</code></pre></div></li>
<li>
<p>Thread Pools</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/thread_pool</span>
<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/stats/thread_pool</span>
<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cat/thread_pool?v</span>
<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/hot_threads</span>
<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/stats/thread_pool</span>
</code></pre></div></li>
</ul>
<h4 id="query-slow-log">
  Query Slow Log
  <a class="anchor" href="#query-slow-log">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">PUT</span> <span style="color:#960050;background-color:#1e0010">my_index/_settings</span>
{
  <span style="color:#f92672">&#34;index.indexing.slowlog&#34;</span>:{
    <span style="color:#f92672">&#34;threshold.index&#34;</span>:{
      <span style="color:#f92672">&#34;warn&#34;</span>:<span style="color:#e6db74">&#34;10s&#34;</span>,
      <span style="color:#f92672">&#34;info&#34;</span>: <span style="color:#e6db74">&#34;4s&#34;</span>,
      <span style="color:#f92672">&#34;debug&#34;</span>:<span style="color:#e6db74">&#34;2s&#34;</span>,
      <span style="color:#f92672">&#34;trace&#34;</span>:<span style="color:#e6db74">&#34;0s&#34;</span>
    },
    <span style="color:#f92672">&#34;level&#34;</span>:<span style="color:#e6db74">&#34;trace&#34;</span>,
    <span style="color:#f92672">&#34;source&#34;</span>:<span style="color:#ae81ff">1000</span>  
  }
}
<span style="color:#960050;background-color:#1e0010">PUT</span> <span style="color:#960050;background-color:#1e0010">my_index/</span>
{
  <span style="color:#f92672">&#34;settings&#34;</span>: {
    <span style="color:#f92672">&#34;index.search.slowlog.threshold&#34;</span>: {
      <span style="color:#f92672">&#34;query.warn&#34;</span>: <span style="color:#e6db74">&#34;10s&#34;</span>,
      <span style="color:#f92672">&#34;query.info&#34;</span>: <span style="color:#e6db74">&#34;3s&#34;</span>,
      <span style="color:#f92672">&#34;query.debug&#34;</span>: <span style="color:#e6db74">&#34;2s&#34;</span>,
      <span style="color:#f92672">&#34;query.trace&#34;</span>: <span style="color:#e6db74">&#34;0s&#34;</span>,
      <span style="color:#f92672">&#34;fetch.warn&#34;</span>: <span style="color:#e6db74">&#34;1s&#34;</span>,
      <span style="color:#f92672">&#34;fetch.info&#34;</span>: <span style="color:#e6db74">&#34;600ms&#34;</span>,
      <span style="color:#f92672">&#34;fetch.debug&#34;</span>: <span style="color:#e6db74">&#34;400ms&#34;</span>,
      <span style="color:#f92672">&#34;fetch.trace&#34;</span>: <span style="color:#e6db74">&#34;0s&#34;</span>
    }
  }
}
</code></pre></div><ul>
<li>
<p>支持将分片上，Search 和 Fetch 阶段的慢查询写入文件</p>
</li>
<li>
<p>支持为Query 和Fetch 分别定义阈值</p>
</li>
<li>
<p>索引级的动态设置，可以按需设置，或者通过 Index Template 统一设定</p>
</li>
<li>
<p>Slog log 文件通过log4j2.properties配置</p>
</li>
</ul>
<h4 id="创建监控dashboard">
  创建监控dashboard
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%9b%91%e6%8e%a7dashboard">#</a>
</h4>
<ul>
<li>开发 Elasticsearch plugin，通过读取相关的监控 API，将数据发送到 ES，或者TSDB</li>
<li>使用Metricbeats 搜索相关指标</li>
<li>使用Kibana 或者 Graffna 创建 Dashboard</li>
<li>可以开发Elasticsearch Exporter，通过 Promtheus 监控 Elasticsearch 集群</li>
</ul>
<h2 id="潜在问题">
  潜在问题
  <a class="anchor" href="#%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98">#</a>
</h2>
<ul>
<li>
<p>集群健康状态</p>
<blockquote>
<p>是否有节点丢失</p>
</blockquote>
</li>
<li>
<p>索引合理性</p>
<blockquote>
<p>索引总数不能过大/ 副本分片尽量不要设置为0 / 主分片尺寸检测 / 索引的字段总数 / 索引是否分配不均衡 / 索引 segment 大小诊断分析</p>
</blockquote>
</li>
<li>
<p>资源使用合理性</p>
<blockquote>
<p>CPU 内存 和磁盘使用情况分析 / 是否存在节点负载不平衡 / 是否需要增加节点</p>
</blockquote>
</li>
<li>
<p>业务操作合理性</p>
<blockquote>
<p>集群状态变更频率，是否在业务高峰期有频繁操作；慢查询监控与分析</p>
</blockquote>
</li>
</ul>
<h2 id="集群-yellow-与-red-问题">
  集群 Yellow 与 Red 问题
  <a class="anchor" href="#%e9%9b%86%e7%be%a4-yellow-%e4%b8%8e-red-%e9%97%ae%e9%a2%98">#</a>
</h2>
<blockquote>
<p>分片健康：</p>
<ul>
<li>红：至少有一个主分片没有分配</li>
<li>黄：至少有一个副本分片没有分配</li>
<li>绿：主副本分片全部正常分配。</li>
</ul>
<p>Red &amp; Yellow 是集群运维中常见的问题。除了集群故障，一些创建，增加副本等操作，都会导致集群短暂的Red 和Yellow，所以监控和报警时都需要设置一定的延时；通过检查节点数，使用ES 提供的相关API，找到真正的原因；可以指定Move 或者Reallocate分片。</p>
</blockquote>
<table>
<thead>
<tr>
<th>GET _cluster/health</th>
<th>集群的状态（检查节点数量）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET cluster/health?level=indices</td>
<td>所有索引的健康状态（查看有问题的索引）</td>
</tr>
<tr>
<td>GET cluster/health/my_index</td>
<td>耽搁索引的健康状态（查看具体的索引）</td>
</tr>
<tr>
<td>GET cluster/health?level=shards</td>
<td>分片级的索引</td>
</tr>
<tr>
<td>GET cluster/allocation/explain</td>
<td>返回第一个未分配Shard 的原因</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>案例</p>
<blockquote>
<ul>
<li>症状：集群变红；</li>
<li>分析，通过 Allocation Explain API 发现 创建索引失败，因为无法找到标记了相应 box type 的节点；</li>
<li>解决：删除索引，集群变绿。重新创建索引，并且指定正确的 routing box type，索引创建成功，集群保持绿色。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>症状：集群变黄；</li>
<li>分析，通过 Allocation Explain API 发现 无法在相同的节点上创建副本；</li>
<li>解决：将索引的副本数设置为0，或者通过增加节点解决。</li>
</ul>
</blockquote>
</li>
<li>
<p>短暂的Yellow or Red</p>
<ul>
<li>INDEX_CREATE：创建索引导致。在索引的全部分片分配完成之前，会有短暂的 Red，不一定代表有问题</li>
<li>CLUSTER_RECOVER：集群重启阶段，也可能变黄</li>
<li>INDEX_REOPEN：Open 一个之前 CLose 的索引</li>
<li>DANGLING_INDEX_IMPORTED：一个节点离开集群期间，有索引被删除。这个节点重新返回时，会有Dangling问题，重新删除这个索引即可。</li>
</ul>
</li>
<li>
<p>常见问题与解决方法</p>
<ul>
<li>
<p>集群变红</p>
<blockquote>
<p>需要检查是否有节点离线。如果有，通常通过重启离线的节点可以解决问题</p>
</blockquote>
</li>
<li>
<p>由于配置导致的问题（例如错误的box_type，错误的副本数）</p>
<blockquote>
<p>需要修复相关的配置；如果是测试的索引，可以直接删除</p>
</blockquote>
</li>
<li>
<p>因为磁盘空间限制，分片规则（shard filtering）引发的</p>
<blockquote>
<p>需要调整规则或者增加节点</p>
</blockquote>
</li>
<li>
<p>对于节点返回集群，导致dangling变红</p>
<blockquote>
<p>可以直接删除 dangling索引</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="提升写性能">
  提升写性能
  <a class="anchor" href="#%e6%8f%90%e5%8d%87%e5%86%99%e6%80%a7%e8%83%bd">#</a>
</h2>
<ul>
<li>ES 默认配置，已经综合考虑了数据可靠性，搜索的实时性质，写入速度，一般不要盲目修改</li>
<li>一切优化，都要基于高质量的数据建模</li>
</ul>
<h4 id="一般方法">
  一般方法
  <a class="anchor" href="#%e4%b8%80%e8%88%ac%e6%96%b9%e6%b3%95">#</a>
</h4>
<ul>
<li>
<p>客户端</p>
<blockquote>
<p>多线程，批量写。可以通过性能测试，确定最佳文档数量；多线程时候需要观察是否有HTTP 429 返回，实现Retry 以及线程数量 的自动调节。</p>
<p>单个bulk请求体的数据量不要太大，官方建议大约5-15mb；写入端的bulk请求超时超时需求足够长，建议60s以上；写入端尽量将数据轮训打到不同节点。</p>
</blockquote>
</li>
<li>
<p>服务器端</p>
<blockquote>
<p>单个性能问题，往往是多个因素造成的。需要先分解问题，在单个节点上进行调整并且结合测试，尽可能压榨硬件资源，以达到最高吞吐量。可以使用更好的硬件，观察CPU / IO Block；线程切换 / 堆栈情况。</p>
</blockquote>
</li>
</ul>
<h4 id="服务端优化">
  服务端优化
  <a class="anchor" href="#%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bc%98%e5%8c%96">#</a>
</h4>
<ul>
<li>
<p>降低IO操作</p>
<blockquote>
<p>使用 ES 自动生成的文档ID，/一些相关的ES 配置，如提升Refresh Interval；</p>
</blockquote>
</li>
<li>
<p>降低 CPU 和 存储开销</p>
<blockquote>
<p>减少不必要分词 / 避免不需要的doc_values / 文档的字段尽量保证相同的顺序，可以提高文档的压缩率</p>
</blockquote>
</li>
<li>
<p>尽可能做到写入和分片的均衡负载，实现水平扩展</p>
<blockquote>
<p>Shard Filtering / Write Load Balancer</p>
</blockquote>
</li>
<li>
<p>调整 Bulk 线程池和队列</p>
<ul>
<li>索引创建属于计算密集型任务，应该使用固定大小的线程池来配置，线程数应该配置成CPU 核心数 + 1，避免过多的上下文切换</li>
<li>来不及处理的放入队列，队列大小可以适当增加，不要过大，否则占用的内存会成为GC的负担</li>
</ul>
</li>
</ul>
<h4 id="关闭无用的功能">
  关闭无用的功能
  <a class="anchor" href="#%e5%85%b3%e9%97%ad%e6%97%a0%e7%94%a8%e7%9a%84%e5%8a%9f%e8%83%bd">#</a>
</h4>
<ul>
<li>
<p>Index设置为 false</p>
<blockquote>
<p>适合只需要聚合不需要搜索</p>
</blockquote>
</li>
<li>
<p>Norms 设置成 false</p>
<blockquote>
<p>适合不需要算分</p>
</blockquote>
</li>
<li>
<p>不要对字符串使用默认的 dynamic mapping</p>
<blockquote>
<p>字段数量过多，会对性能产生表达的影响</p>
</blockquote>
</li>
<li>
<p>Index_options控制在创建倒排索引时，哪些内容会被添加到 倒排索引中</p>
<blockquote>
<p>优化这些配置，一定程度可以节约CPU</p>
</blockquote>
</li>
<li>
<p>关闭_source，减少IO 操作</p>
<blockquote>
<p>适合指标型数据</p>
</blockquote>
</li>
</ul>
<h4 id="取舍">
  取舍
  <a class="anchor" href="#%e5%8f%96%e8%88%8d">#</a>
</h4>
<blockquote>
<p>如果需要追求极致的写入速度，可以牺牲数据可靠性及搜索实时性以换取性能。</p>
<ul>
<li>牺牲可靠性：将副本分片设置为0，写入完毕再调整回去</li>
<li>牺牲搜索实时性：增加Refresh Interval 的时间</li>
<li>牺牲可靠性：修改Translog 的配置</li>
</ul>
</blockquote>
<h4 id="数据写入过程的可优化点">
  数据写入过程的可优化点
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%86%99%e5%85%a5%e8%bf%87%e7%a8%8b%e7%9a%84%e5%8f%af%e4%bc%98%e5%8c%96%e7%82%b9">#</a>
</h4>
<ul>
<li>
<p>Refresh Interval</p>
<blockquote>
<p>增加refresh_interval 的数值，降低Refresh 的频率。默认值为 1S，如果设置成-1，会禁止自动 refresh。此举避免过于频繁的refresh而生产过多的segment文件，但是会降低搜索的实时性。另外需要修改参数 indices.memory.index_buffer_size（默认是10%，会导致自动触发refresh）。</p>
</blockquote>
</li>
<li>
<p>Translog</p>
<blockquote>
<p>降低写磁盘的频率，但是会降低容灾能力。</p>
<ul>
<li>Index.translog.durability：默认是request，每个请求都落盘。设置成async，异步写入</li>
<li>index.translog.sync_interval 设置成60s，每分钟执行一次</li>
<li>index.translog.flush_threshod_size：默认521 mb，可以适当调大。当translog超过改值，会触发flush</li>
</ul>
</blockquote>
</li>
<li>
<p>分片设定</p>
<ul>
<li>
<p>副本在写入时设为0，完成后再增加</p>
</li>
<li>
<p>合理设置主分片数，确保均匀分配在所有数据节点上</p>
<blockquote>
<p>index.routing.allocation.total_share_per_node：限定每个索引在每个节点可分配的主分片数；</p>
<p>比如5个节点的集群，所有有5个主分片，一个副本，每个节点的分片数：（5 + 5） / 5 = 2，生产环境要适当调大这个数字，避免有节点下线时，分片无法正常迁移。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">PUT</span> <span style="color:#960050;background-color:#1e0010">myindex</span>
{
  <span style="color:#f92672">&#34;settings&#34;</span>: {
    <span style="color:#f92672">&#34;index&#34;</span>: {
      <span style="color:#75715e">// 30s一次Refresh
</span><span style="color:#75715e"></span>      <span style="color:#f92672">&#34;refresh_interval&#34;</span>: <span style="color:#e6db74">&#34;30s&#34;</span>,
      <span style="color:#f92672">&#34;number_of_shards&#34;</span>: <span style="color:#e6db74">&#34;2&#34;</span>
    },
    <span style="color:#f92672">&#34;routing&#34;</span>: {
      <span style="color:#f92672">&#34;allocation&#34;</span>: {
        <span style="color:#75715e">// 控制分片，避免数据热点
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&#34;total_shards_per_node&#34;</span>: <span style="color:#e6db74">&#34;3&#34;</span>
      }
    },
    <span style="color:#f92672">&#34;translog&#34;</span>: {
      <span style="color:#75715e">// 降低translog落盘
</span><span style="color:#75715e"></span>      <span style="color:#f92672">&#34;sync_interval&#34;</span>: <span style="color:#e6db74">&#34;30s&#34;</span>,
      <span style="color:#f92672">&#34;durability&#34;</span>: <span style="color:#e6db74">&#34;async&#34;</span>
    },
    <span style="color:#f92672">&#34;number_of_replicas&#34;</span>: <span style="color:#ae81ff">0</span>
  },
  <span style="color:#f92672">&#34;mappings&#34;</span>: {
    <span style="color:#75715e">// 避免不必要的字段索引。必要时可以通过update by query 索引必要的字段
</span><span style="color:#75715e"></span>    <span style="color:#f92672">&#34;dynamic&#34;</span>: <span style="color:#66d9ef">false</span>,
    <span style="color:#f92672">&#34;properties&#34;</span>: {}
  }
}
</code></pre></div><h2 id="提升读性能">
  提升读性能
  <a class="anchor" href="#%e6%8f%90%e5%8d%87%e8%af%bb%e6%80%a7%e8%83%bd">#</a>
</h2>
<h4 id="数据建模">
  数据建模
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%bb%ba%e6%a8%a1">#</a>
</h4>
<ul>
<li>尽量Denormalize 数据</li>
<li>尽量将数据先行计算，然后保存到Elasticsearch 中，尽量避免查询时的Script 计算</li>
<li>尽量使用 Filter Context，利用缓存机制，减少不必要的算分</li>
<li>结合profile，explain API 分析慢查询的问题，持续优化数据模型</li>
<li>严禁 使用 * 开头通配符 Terms查询</li>
</ul>
<h4 id="优化分片">
  优化分片
  <a class="anchor" href="#%e4%bc%98%e5%8c%96%e5%88%86%e7%89%87">#</a>
</h4>
<ul>
<li>避免 Over Sharing一个查询需要访问每一个分片，分片过多，会导致不必要的查询开销</li>
<li>结合应用场景，控制单个分片的尺寸：
<ul>
<li>Search 20G</li>
<li>Logging 40G</li>
<li>Force-merge Read-only索引</li>
<li>使用基于时间序列的索引，将只读的索引进行force merge，减少segment数量。</li>
</ul>
</li>
</ul>
<h2 id="段合并优化及注意事项">
  段合并优化及注意事项
  <a class="anchor" href="#%e6%ae%b5%e5%90%88%e5%b9%b6%e4%bc%98%e5%8c%96%e5%8f%8a%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#</a>
</h2>
<h4 id="merge优化">
  Merge优化
  <a class="anchor" href="#merge%e4%bc%98%e5%8c%96">#</a>
</h4>
<blockquote>
<p>ES 和 Lucene 会自动进行Merge操作，Merge操作相对比较重，需要优化，降低对系统的影响。</p>
<ol>
<li>降低分段产生的数量/频率；
<ol>
<li>可以将Refresh Interval 调整到分钟级别/ indices.memory.index_buffer_size（默认是10%）</li>
<li>尽量避免文档的更新操作</li>
</ol>
</li>
<li>降低最大分段大小，避免较大的分段继续参加Merge，节省系统资源。（最终会有多个分段）
<ol>
<li>Index.merge.policy.segments_per_tier，默认为 10，越小需要越多的合并操作</li>
<li>Index.merge.policy.max_merged_segment，默认 5GB，操作此大小以后，就不再参与后续的合并操作</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="force-merge">
  Force Merge
  <a class="anchor" href="#force-merge">#</a>
</h4>
<blockquote>
<p>当 Index 不再有写入操作的时候，建议对其进行force merge，可以提升查询速度 / 减少内存开销。</p>
</blockquote>
<pre tabindex="0"><code class="language-jso" data-lang="jso">POST my_index/_forcemerge?max_num_segments=1
GET _cat/segments/my_index?v
</code></pre><blockquote>
<p>最终分成的segments越少越好，最好可以 force merge成1个。但是，Force Merge 会占用大量网络资源、IO和CPU。如果不能再业务高峰期之前做完，就需要考虑增大最终的分段数，加快force_merge完成的时间。</p>
</blockquote>
<h2 id="缓存及使用breaker限制内存使用">
  缓存及使用Breaker限制内存使用
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%8f%8a%e4%bd%bf%e7%94%a8breaker%e9%99%90%e5%88%b6%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8">#</a>
</h2>
<h4 id="缓存分类">
  缓存分类
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%88%86%e7%b1%bb">#</a>
</h4>
<ul>
<li>
<p>Node Query Cache</p>
<blockquote>
<p>每一个节点都有一个Node Query缓存，由该节点的所有Shard 共享，只缓存Filter Context 相关内容，采用LRU算法。</p>
</blockquote>
<ul>
<li>
<p>静态配置（需要设置在每个 Data Node 上）</p>
<blockquote>
<p>Node Level - indices.queries.cache.size : 10%</p>
<p>Index level - index.queries.cache.enabled:true</p>
</blockquote>
</li>
<li>
<p>缓存失效</p>
<blockquote>
<p>保存的是Segment 级缓存命中的结果。Segment 被合并后，缓存会失效。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Shard Request Cache</p>
<blockquote>
<p>缓存每个分片上的查询结果，只会缓存设置了 size = 0 的查询对应的结果。不会缓存hits。但是会缓存Aggregation 和Suggestions。</p>
<p>使用LRU算法，将整个JSON 查询串作为Key，与JSON对象的顺序有关。</p>
</blockquote>
<ul>
<li>
<p>静态配置</p>
<blockquote>
<p>数据节点 ：indices.requests.cache.size：1%</p>
</blockquote>
</li>
<li>
<p>缓存失效</p>
<blockquote>
<p>分配Refresh 的时候，Shard Request Cache 会失效。如果Shard 对应的数据频繁发生变化，该缓存的效率会很差。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Fielddata Cache</p>
<blockquote>
<p>除了Text 类型，默认都采用doc_values，节约了内存。Text 类型的字段需要打开Fileddata 才能对其进行聚合和排序，但是Text 经过分词，排序和聚合效果不佳，建议不要轻易使用。</p>
<p>Aggregation 的 Global ordinals 也保存在Fielddata cache中。</p>
</blockquote>
<ul>
<li>
<p>配置</p>
<blockquote>
<p>可以控制 Indices.fielddata.cache.size ，避免产生GC（默认无限制）</p>
</blockquote>
</li>
<li>
<p>缓存失效</p>
<blockquote>
<p>Segment 被合并后会失效。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="内存管理与断路器">
  内存管理与断路器
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%8e%e6%96%ad%e8%b7%af%e5%99%a8">#</a>
</h4>
<blockquote>
<p>Elasticsearch 高效运维依赖于内存的合理分配，可用内存一半分配给JVM，一半留给操作系统，缓存索引文件。内存问题，可能引发的问题：</p>
<ol>
<li>长时间GC，影响节点，导致集群相应缓慢；</li>
<li>OOM，导致丢节点。</li>
</ol>
</blockquote>
<ul>
<li>
<p>查看各个节点内存状况</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cat/nodes?v</span>

<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_nodes/stats/indices?pretty</span>

<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cat/nodes?v&amp;h=name,queryCacheMemory,queryCacheEvictions,requestCacheMemory,requestCacheHitCount,request_cache.miss_count</span>

<span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">_cat/nodes?h=name,port,segments.memory,segments.index_writer_memory,fielddata.memory_size,query_cache.memory_size,request_cache.memory_size&amp;v</span>
</code></pre></div></li>
<li>
<p>常见的内存问题</p>
<ul>
<li>
<p>Segments 个数过多，导致 full GC</p>
<blockquote>
<p>现象：集群整体响应缓慢，没有特别多的数据读写。但是发现节点在持续进行 Full GC</p>
<p>分析：查看Elasticsearch 的内存使用，发现 segments.memory占用很大空间</p>
<p>解决：通过 force merge，把segments合并成一个</p>
<p>建议：对于不再写入和更新的索引，可以将其设置为只读。同时，进行 force merge操作。如果问题依然存在，则需要考虑扩容。</p>
</blockquote>
</li>
<li>
<p>Field data cache 过大，导致 full GC</p>
<blockquote>
<p>现象：集群整体响应缓慢，也没有特别多的数据读写。但是发现节点在持续进行 Full GC</p>
<p>分析：查看Elasticsearch 的内存使用，发现fielddata.memory.size 占用很大空间。同时。数据不存在写入和更新，也执行过segments merge。</p>
<p>解决：将 indices.fielddata.cache.size 设小，重启节点，堆内存恢复正常</p>
<p>建议：Field data cache 的构建比较重，Elasticsearch 不会主动释放，所以这个值设置的保守一些。如果业务上确实有所需要，可以通过增加节点，扩容解决。</p>
</blockquote>
</li>
<li>
<p>复杂的嵌套聚合，导致集群full GC</p>
<blockquote>
<p>现象：节点响应缓慢，持续进行 Full GC</p>
<p>分析：导出 Dump 分析。发现内存中有大量 bucket对象，查看日志发现复杂的嵌套聚合</p>
<p>解决：优化聚合</p>
<p>建议：在大量数据集上进行嵌套聚合查询，需要很大的堆内存来完成。如果业务场景确实需要，则需要增加硬件进行扩展。同时，为了避免这类查询影响整个集群，需要设置 Circuit Breaker 和 search.max.buckets 的数值</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Circuit Breaker</p>
<blockquote>
<p>断路器，避免不合理操作引发的 OOM，每个断路器可以指定内存使用的限制。</p>
<ul>
<li>Parent circuit breaker：设置所有的熔断器可以使用的内存的总量</li>
<li>Fielddata circult breaker：加载fielddata 所需要的内存</li>
<li>Request circuit breaker：防止每个请求级数据结构超过一定的内存（例如聚合计算的内存）</li>
<li>In fight circuit breaker：Request中的断路器</li>
<li>Accounting request circuit breaker：请求结束后不能释放对象所占用的内存</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// Circuit Breaker统计信息
</span><span style="color:#75715e">// Tripped 大于0，说明有过熔断
</span><span style="color:#75715e">// Limit size 与 estimated size越接近，越可能引发熔断
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">GET</span> <span style="color:#960050;background-color:#1e0010">/_nodes/stats/breaker?</span>
</code></pre></div><blockquote>
<p>不要触发了熔断，就盲目调大参数，有可能会导致集群出问题，也不要盲目调小，需要进行评估。将集群升到 7.x，更好的Circuit Breaker 实现机制：增加了 indices.breaker.total.use_real_memory 配置项，可以更加精准的分析内存情况，避免OOM。</p>
</blockquote>
</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#常用配置">常用配置</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#监控集群">监控集群</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#潜在问题">潜在问题</a></li>
    <li><a href="#集群-yellow-与-red-问题">集群 Yellow 与 Red 问题</a></li>
    <li><a href="#提升写性能">提升写性能</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#提升读性能">提升读性能</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#段合并优化及注意事项">段合并优化及注意事项</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#缓存及使用breaker限制内存使用">缓存及使用Breaker限制内存使用</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












