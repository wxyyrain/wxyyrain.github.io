<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构和算法 on My New Hugo Site</title>
    <link>https://wxyyrain.github.io/docs/algorithm/</link>
    <description>Recent content in 数据结构和算法 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Mar 2022 11:00:43 +0800</lastBuildDate><atom:link href="https://wxyyrain.github.io/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一维</title>
      <link>https://wxyyrain.github.io/docs/algorithm/mds/base_data_structure/</link>
      <pubDate>Mon, 31 Jan 2022 15:47:28 +0800</pubDate>
      
      <guid>https://wxyyrain.github.io/docs/algorithm/mds/base_data_structure/</guid>
      <description>数组（array） #   数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
 特点 #    线性表
 线性表就是数据排列像一条线一样的数据结构，每个线性表上的数据最多只有前和后两个方向。
  链表、队列、栈等也是线性表结构。
  二叉树、堆、图等，是非线性表，因为数据之间并不是简单的前后关系。
   连续的内存空间和相同的数据类型
 这两个限制，使数组有了随机访问的特性，计算机可以使用以下寻址公式，随机访问数组中的某个元素：
 a[i]_address = base_address + i * data_type_size  base_address 为数组的起始地址，data_type_size是每个元素占用的内存的大小，i是元素的索引。
   低效的插入和删除
 为了保证数组的连续性，在进行插入、删除操作的时候，需要做大量的数据迁移工作，因此效率会低一些。
   插入
 假设数组的长度为 n，如果需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，需要将第 k～n 这部分的元素都顺序地往后挪一位。
如果数据插在末尾，这时的时间复杂度为 O(1)。
但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。平均情况时间复杂度为 (1+2+…n)/n=O(n)。
   删除
 跟插入数据类似，如果要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。
   优化</description>
    </item>
    
    <item>
      <title>二维</title>
      <link>https://wxyyrain.github.io/docs/algorithm/mds/data_structure_2/</link>
      <pubDate>Sat, 26 Mar 2022 10:48:23 +0800</pubDate>
      
      <guid>https://wxyyrain.github.io/docs/algorithm/mds/data_structure_2/</guid>
      <description>树（tree） #  图（graph） #  二叉搜索树（binary search tree） #  遍历 #   前序：根&amp;ndash;左&amp;ndash;右 中序：左&amp;ndash;根&amp;ndash;右 后序：左&amp;ndash;右&amp;ndash;根     题目 编号     二叉树的中序遍历 94   二叉树的前序遍历 144   N叉树的后续遍历 590   N叉树的前续遍历 589   N叉树的层序遍历 429    堆（heap） #  并查集（disjoint set） #  字典树（Trie） #  </description>
    </item>
    
    <item>
      <title>特殊</title>
      <link>https://wxyyrain.github.io/docs/algorithm/mds/data_structure_3/</link>
      <pubDate>Sat, 26 Mar 2022 10:48:32 +0800</pubDate>
      
      <guid>https://wxyyrain.github.io/docs/algorithm/mds/data_structure_3/</guid>
      <description>位运算（bitewise） #  布隆过滤器（bloom filter） #  LRU Cache #  </description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://wxyyrain.github.io/docs/algorithm/mds/algorithm/</link>
      <pubDate>Sat, 26 Mar 2022 11:00:43 +0800</pubDate>
      
      <guid>https://wxyyrain.github.io/docs/algorithm/mds/algorithm/</guid>
      <description>递归（recursion） #  public void recur(int level, int param) { // terminator  if (level &amp;gt; MAX_LEVEL) { // process result  return; } // process current logic  process(level, param); // drill down  recur( level: level + 1, newParam); // restore current status  }    题目 编号     爬楼梯 70   括号生成 22   翻转二叉树 226   验证二叉搜索树 98   二叉树的最大深度 104   二叉树的最小深度 111   二叉树的序列化与反序列化 297   二叉树的最近公共祖先 236   从前序与中序遍历序列构造二叉树 105   组合 77   全排列 46   全排列2 47     divide &amp;amp; conquer backtrace     题目 编号     Pow(x, y) 50   子集 78   多数元素 169   电话号码的字母组合 17   N皇后 51   二叉树的层次遍历 102   最小基因变化 433   括号生成 22   在每个树行中找最大值 515   单词接龙 127   单词接龙2 126   岛屿数量 200   扫雷游戏 529    搜索（search） #    dfs</description>
    </item>
    
  </channel>
</rss>
